//
//  Promise.swift
//  NewsReader
//
//  Created by Florent Bruneau on 18/07/2015.
//  Copyright Â© 2015 Florent Bruneau. All rights reserved.
//

import Foundation
import Cocoa

private enum State<T> {
    case success(T)
    case error(Error)
    case cancelled
    case running
}

/// Error generated by the Promises
public enum PromiseError : Error, CustomStringConvertible {
    /// Error encapsulating an uncaught error.
    ///
    /// This error is generated when an error remains uncaught by a chaining
    /// level. It wraps the original error as well as a counter of the number
    /// of level it traversed without being caught.
    ///
    /// The minimal value for the counter is 1.
    ///
    /// - parameter ErrorType: the original error
    /// - parameter Int: the number of traversed chaining levels
    case uncaughtError(Error, Int)

    /// Error emitted when a promise get cancelled.
    case cancelled

    public var description : String {
        switch self {
        case .cancelled:
            return "operation cancelled"

        case .uncaughtError(let e, let depth):
            return "uncaught error (\(depth) levels): \(e)"
        }
    }
}

private struct PromiseHandler<T> {
    fileprivate typealias SuccessHandler = (T) throws -> Void
    fileprivate typealias ErrorHandler = (Error) throws -> Void

    fileprivate let successHandler : SuccessHandler?
    fileprivate let errorHandler : ErrorHandler?
    fileprivate let onSuccess : (Void) -> Void
    fileprivate let onError : (Error) -> Void

    fileprivate func succeed(_ arg: T) {
        do {
            try self.successHandler?(arg)
            self.onSuccess()
        } catch let e {
            self.onError(e)
        }
    }

    fileprivate func fail(_ res: Error) {
        if let errorHandler = self.errorHandler {
            do {
                try errorHandler(res)
                self.onSuccess()
            } catch let e {
                self.onError(e)
            }
        } else {
            switch (res) {
            case PromiseError.uncaughtError(let sub, let depth):
                self.onError(PromiseError.uncaughtError(sub, depth + 1))

            default:
                self.onError(PromiseError.uncaughtError(res, 1))
            }
        }
    }
}

private class PromiseOperation<T> : Operation {
    fileprivate var state : State<T> = .running
    fileprivate let operation : () throws -> T
    fileprivate let onSuccess : (T) -> Void
    fileprivate let onError : (Error) -> Void
    fileprivate let creationQueue : OperationQueue?

    fileprivate init(operation: @escaping () throws -> T, onSuccess: @escaping (T) -> Void, onError: @escaping (Error) -> Void) {
        self.operation = operation
        self.creationQueue = OperationQueue.current
        self.onSuccess = onSuccess
        self.onError = onError
        super.init()
    }

    fileprivate func notify() {
        switch self.state {
        case .running:
            self.onError(PromiseError.cancelled)
            
        case .error(let e):
            self.onError(e)
            
        case .success(let r):
            self.onSuccess(r)
            
        case .cancelled:
            break
        }
    }

    override func main() {
        do {
            self.state = .success(try self.operation())
        } catch let e {
            self.state = .error(e)
        }

        if let creationQueue = self.creationQueue {
            creationQueue.addOperation(self.notify)
        } else {
            OperationQueue.main.addOperation(self.notify)
        }
    }
}

/// A promise object represent an operation that is expected to finish in the future
///
/// A promise object can be used in order to associate action to the termination of
/// an asynchronous operation. This feature is mainly inspired by the Javascript
/// feature introduced in ES6.
///
/// A promise wraps the result of an operation. That result may not be known at
/// the creation of the promise object. The promise let prives a _promise_ that
/// the value will be provided whenever it is known.
///
/// In order to achieve this, the promise let other register callback to be called
/// whenever the result is known. If the result is already known the callback is
/// called immediately.
///
/// A promise can be in one of the four following states:
///  - Running: the action is still in progress, the result is unknown
///  - Success: the action has successfully ended
///  - Error: the action failed
///  - Cancelled: the action has been cancelled. In the point of the view of 
///    the user, this is equivalent to failing with error `.Cancelled`
///
/// Once the promise has left the `Running` state, it is in its definitive state
///
/// Promise allow chaining. A registered callback may return a new promise or
/// throw an error, that will then be propagated to the chained objects. A callback
/// can be registered using the `.then()` and the `.thenChain()` methods. The first
/// one takes a synchronous Void callback. In both case the callback may throw
/// an error that will be propagated in the promise chain.
///
/// Error are treated like exception, in that they propagate as long as they
/// have not been caught using a error handler. Error handler can be registered
/// using the `.otherwise()`, `.then(otherwise:)` or `.otherwiseChain()` methods.
/// When an error is not caught in a chain, it is wrapped in an `.UncaughtError`
/// error letting you known how many chaining layer the error traversed before
/// being caught.
///
/// - note: `.then().otherwise()` and `.then(otherwise:)` are not equivalent since
///   in case of error, in the former case, the error will traverse one chaining
///   layer before being caught while in the second one it is caught in the first
///   chaining layer.
open class Promise<T> {
    public typealias SuccessHandler = (T) throws -> Void
    public typealias ErrorHandler = (Error) throws -> Void

    public typealias Constructor = (@escaping (T) -> Void, @escaping (Error) -> Void) throws -> Void
    public typealias Cancellor = (Void) -> Void

    fileprivate var handlers : [PromiseHandler<T>] = []
    fileprivate var state = State<T>.running
    fileprivate let onCancel : Cancellor?

    fileprivate init(action: Constructor, onOptCancel: Cancellor?) {
        self.onCancel = onOptCancel
        do {
            try action(self.onSuccess, self.onError)
        } catch let e {
            self.onError(e)
        }
    }

    /// Create a promise for having the result of the given action.
    ///
    /// The action is a callback that receives the two function to call, one
    /// to register a success result, one to register an error. If the action
    /// throws an error, it is automatically registered as a failure.
    ///
    /// - parameter action: the action whose result is wrapped by the promise
    public convenience init(action: Constructor) {
        self.init(action: action, onOptCancel: nil)
    }

    /// Create a promise with a cancellable action.
    ///
    /// The action is a callback that receives the two function to call, one
    /// to register a success result, one to register an error. If the action
    /// throws an error, it is automatically registered as a failure.
    ///
    /// The additional `onCancel` parameter is called when the promise is 
    /// cancelled by the user.
    ///
    /// - parameter action: the action whose result is wrapped by the promise
    /// - parameter onCancel: the callback to call to cancel the action
    public convenience init(action: Constructor, onCancel: @escaping Cancellor) {
        self.init(action: action, onOptCancel: onCancel)
    }

    /// Create a promise that get executed concurrently
    ///
    /// This creates a promise for a function that is executed in background.
    ///
    /// This uses the NSOperation infrastructure to run the provided operation
    /// concurrently.
    ///
    /// - parameter operation: the function to execute
    public convenience init(queue: OperationQueue, operation: @escaping () throws -> T) {
        self.init(action: {
            (onSuccess: @escaping (T) -> Void, onError: @escaping (Error) -> Void) in

            let op = PromiseOperation<T>(operation: operation, onSuccess: onSuccess, onError: onError)
            queue.addOperation(op)
        })
    }

    /// Create a promise that has already succeeded
    ///
    /// - parameter success: the result of the promise
    public convenience init(success: T) {
        self.init(action: {
            (onSuccess, onError) in

            onSuccess(success)
        })
    }

    /// Create a promise that has already failed
    ///
    /// - parameter failed: the error of the promise
    public convenience init(failure: Error) {
        self.init(action: {
            (onSuccess, onError) in

            onError(failure)
        })
    }

    fileprivate func onSuccess(_ res: T) {
        switch (self.state) {
        case .running:
            self.state = .success(res)
            for handler in self.handlers {
                handler.succeed(res)
            }
            self.handlers.removeAll()

        case .cancelled:
            break

        default:
            assert (false)
        }
    }

    fileprivate func onError(_ res: Error) {
        switch (self.state) {
        case .running:
            self.state = .error(res)
            for handler in self.handlers {
                handler.fail(res)
            }
            self.handlers.removeAll()

        case .cancelled:
            break

        default:
            assert (false)
        }
    }

    /// Cancel a running promise.
    ///
    /// This cause the promise to fail with the `.Cancelled` error. If the
    /// action is cancellable, its `onCancel` is called.
    open func cancel() {
        guard case .running = self.state else {
            return
        }

        self.state = .cancelled
        self.onCancel?()
        for handler in self.handlers {
            handler.fail(PromiseError.cancelled)
        }
        self.handlers.removeAll()
    }

    fileprivate func registerHandler(_ success: SuccessHandler?, error: ErrorHandler?) -> Promise<Void> {
        var ph : PromiseHandler<T>?
        let promise = Promise<Void>(action: {
            (onSuccess: @escaping () -> Void, onError: @escaping (Error) -> Void) in

            ph = PromiseHandler(successHandler: success, errorHandler: error, onSuccess: onSuccess, onError: onError)
        }, onCancel: { self.cancel() })

        assert (ph != nil)

        switch (self.state) {
        case .success(let result):
            ph?.succeed(result)

        case .error(let result):
            ph?.fail(result)

        case .cancelled:
            ph?.fail(PromiseError.cancelled)

        case .running:
            self.handlers.append(ph!)
        }
        return promise
    }

    /// Register a callback to be called when the result of the action is known.
    ///
    /// The registered function will be called whenever the result of the promise
    /// is known. If the promise fails, then no callback will the called and the
    /// returned promise will fail, receiving an `UncaughtError` wrapping the
    /// error.
    ///
    /// - note: Several handlers may be registered on the same promise. In that
    ///    case, they are called in their registration order.
    ///
    /// - parameter handler: the callback to call when the promise succeed
    /// - returns: a promise that will be successful if the current promise is
    ///    successful and `handler` does not fails, or fail if the current
    ///    promise fails or `handlers` fails.
    @discardableResult open func then(_ handler: @escaping SuccessHandler) -> Promise<Void> {
        return self.registerHandler(handler, error: nil)
    }

    /// Register a pair of callback and error handler to be called when the
    /// result of the action is known.
    ///
    /// The registered functions will be called whenever the result of the promise
    /// is known. The `handler` is called in case of success, while the `otherwise`
    /// callback is called in case of error.
    ///
    /// - note: Several handlers may be registered on the same promise. In that
    ///    case, they are called in their registration order.
    ///
    /// - parameter handler: the callback to call when the promise succeed
    /// - returns: a promise that will be successful if the current promise is
    ///    successful and `handler` or `otherwise` does not fails, or fail if
    ///    the called function fails.
    @discardableResult open func then(_ handler: @escaping SuccessHandler, otherwise: @escaping ErrorHandler) -> Promise<Void> {
        return self.registerHandler(handler, error: otherwise)
    }

    /// Register a callback to be called when the action fails.
    ///
    /// The registered function will be called whenever the promise fails.
    /// If the promise succeeds, then no callback will the called.
    ///
    /// - note: Several handlers may be registered on the same promise. In that
    ///    case, they are called in their registration order.
    ///
    /// - parameter handler: the callback to call when the promise fails
    /// - returns: a promise that will be successful if the current promise is
    ///    successful or if the current promise fails and `handler` does not
    ///    fail, or fail if the current promise fails and `handlers` fails.
    @discardableResult open func otherwise(_ handler: @escaping ErrorHandler) -> Promise<Void> {
        return self.registerHandler(nil, error: handler)
    }

    /// Register a new action to executed in case of success of the promise.
    ///
    /// Chains a new promise when the current promise succeed. This allows chaining
    /// asynchronous actions. When the current promise succeeds, `handler` is
    /// called and returns a new promise. This function wraps that new promise
    /// so that it can be waited for even before `handler` is executed.
    ///
    /// If the current promise fails, then the returned promise will fail
    /// receiving an `UncaughtError`
    ///
    /// - note: Several handlers may be registered on the same promise. In that
    ///    case, they are called in their registration order.
    ///
    /// - parameter handler: the callback to call when the promise succeed
    /// - returns: a promise that will be successful if the current promise is
    ///    successful and the promise retruned by `handler` is successful, or
    ///    fail if the current promise fails or `handlers` fails or the promise
    ///    returned by `handler` fails.
    @discardableResult open func thenChain<OnSubSuccess>(_ handler: @escaping (T) throws -> Promise<OnSubSuccess>) -> Promise<OnSubSuccess> {
        var subPromise : Promise<OnSubSuccess>?

        return Promise<OnSubSuccess>(action: {
            (onSubSuccess, onSubError) in
            _ = self.then() {
                (result) in

                do {
                    subPromise = try handler(result)
                    _ = subPromise!.then(onSubSuccess, otherwise: onSubError)
                } catch let e {
                    onSubError(e)
                }
            }
        }, onCancel: {
            if let promise = subPromise {
                promise.cancel()
            } else {
                self.cancel()
            }
        })
    }

    /// Register a new action to executed in case of error of the promise.
    ///
    /// Chains a new promise when the current promise fails. This allows chaining
    /// asynchronous actions. When the current promise fails, `handler` is
    /// called and returns a new promise. This function wraps that new promise
    /// so that it can be waited for even before `handler` is executed.
    ///
    /// If the current promise fails, then the returned promise will fail
    /// receiving an `UncaughtError`
    ///
    /// - note: Several handlers may be registered on the same promise. In that
    ///    case, they are called in their registration order.
    /// - warning: if the current promise is successful, it won't be chained to
    ///    the returned promise.
    ///
    /// - parameter handler: the callback to call when the promise fails
    /// - returns: a promise that will be successful if the current promise is
    ///    failed and the promise returned by `handler` is successful, or
    ///    fails if `handlers` fails or the promise returned by `handler` fails.
    @discardableResult open func otherwiseChain<OnSubSuccess>(_ handler: @escaping (Error) throws -> Promise<OnSubSuccess>) -> Promise<OnSubSuccess> {
        var subPromise : Promise<OnSubSuccess>?

        return Promise<OnSubSuccess>(action: {
            (onSubSuccess, onSubError) in
            _ = self.otherwise() {
                (result) in

                do {
                    subPromise = try handler(result)
                    _ = subPromise!.then(onSubSuccess, otherwise: onSubError)
                } catch let e {
                    onSubError(e)
                }
            }
        }, onCancel: {
            if let promise = subPromise {
                promise.cancel()
            } else {
                self.cancel()
            }
        })
    }
}
